# Makefile
[参考](https://blog.csdn.net/weixin_38391755/article/details/80380786)

​		一般来说，无论是C还是C++，首先要把源文件编译成**中间代码文件**。在Windows下是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做**编译（compile**）。然后再把大量的Object File合成执行文件，这个动作叫作**链接（link）**。

​		编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。 
链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫**“库文件”（Library File)**，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。
Make规则

```makefile
target:prerequisites
    command
```
**

**target**也就是一个目标文件，可以是**Object File**，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。
**prerequisites**就是，要生成那个target所需要的文件或是目标。
**command**也就是make需要执行的命令。（任意的Shell命令）



 【注】：在看别人写的Makefile文件时，你可能会碰到以下三个变量：\$@，\$^，$<代表的意义分别是： 
他们三个是十分重要的三个变量，所代表的含义分别是：
==\$@--目标文件，\$^--所有的依赖文件，\$<--第一个依赖文件。==



​		在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。



Make是如何工作的
1.  make会在当前目录下找名字叫“Makefile”或“makefile”的文件。
2.  如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。
3.  如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。
4.  如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）
5.  当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件声明make的终极任务，也就是执行文件edit了。

